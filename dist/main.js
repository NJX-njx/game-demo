class x{constructor(){if(x.instance)return x.instance;x.instance=this}async loadJSON(t){const i=await fetch(t);if(!i.ok)throw new Error(`Failed to load JSON: ${t}`);return await i.json()}async loadImg(t){return new Promise((i,e)=>{const s=new Image;s.src=t,s.onload=()=>i(s),s.onerror=a=>e(new Error(`Failed to load image: ${t}`))})}}const L=new x;class b{constructor(){if(b.instance)return b.instance;b.instance=this}async load(){this.tempCanvas=document.querySelector("canvas#buffer"),this.texturesURL=await L.loadJSON("assets/imgs/Textures.json"),this.textures={};const t=new Map,i=[];for(const s of Object.keys(this.texturesURL))for(const a of Object.keys(this.texturesURL[s]))i.push(this.texturesURL[s][a]);const e=i.map(async s=>{const a=await fetch(s);if(!a.ok)throw new Error(`Failed to load image: ${s}`);const n=await a.blob(),h=await createImageBitmap(n);t.set(s,h)});await Promise.all(e);for(const s of Object.keys(this.texturesURL)){this.textures[s]={};for(const a of Object.keys(this.texturesURL[s]))this.textures[s][a]=t.get(this.texturesURL[s][a])}}getTexture(t,i="0"){return this.textures[t]&&this.textures[t][i]?this.textures[t][i]:null}}const E=new b;class w{constructor(){if(w.instance)return w.instance;w.instance=this,this.canvas=document.getElementById("canvas"),this.container=document.querySelector("#game-container"),this.isCapture=!1,this.ratio=this.canvas.width/this.container.clientWidth,this.x=0,this.y=0,this.prevX=0,this.prevY=0,this.left=!1,this.right=!1,this.clickable=!1,this.container.addEventListener("click",()=>this.capture()),this.container.addEventListener("mousemove",t=>this.move(t)),this.container.addEventListener("mousedown",t=>this.mouseDown(t)),this.container.addEventListener("mouseup",t=>this.mouseUp(t)),document.addEventListener("pointerlockchange",()=>this.uncapture()),document.addEventListener("visibilitychange",()=>this.blur()),document.addEventListener("click",()=>m.continue())}async capture(){this.isCapture||(await this.container.requestPointerLock({unadjustedMovement:!1}),this.isCapture=!0,setTimeout(()=>{this.clickable=!0},200))}blur(){document.visibilityState==="hidden"&&(document.exitPointerLock(),this.uncapture())}uncapture(){console.debug("uncapture: ",document.pointerLockElement,this.container),console.debug("uncapture: ",document.pointerLockElement!==this.container),document.pointerLockElement!==this.container&&(this.isCapture=!1,m.pause()),this.clickable=!1}mouseDown(t){t.preventDefault(),this.clickable&&(t.button===0&&(this.left=!0),t.button===2&&(this.right=!0))}mouseUp(t){t.preventDefault(),t.button===0&&(this.left=!1),t.button===2&&(this.right=!1)}move(t){t.preventDefault(),this.isCapture&&(this.ratio=this.canvas.width/this.container.clientWidth,this.x+=t.layerX-this.prevX,this.y+=t.layerY-this.prevY,this.prevX=t.layerX,this.prevY=t.layerY,this.x+=t.movementX*this.ratio,this.y+=t.movementY*this.ratio,this.x<0&&(this.x=0),this.y<0&&(this.y=0),this.x>this.canvas.width&&(this.x=this.canvas.width),this.y>this.canvas.height&&(this.y=this.canvas.height))}draw(t){t.drawImage(E.getTexture("cursor"),12,9,16,22,this.x-4,this.y-5,16,22)}get position(){return new Vector(this.x,this.y)}}class k{status;KEYMAP=new Map([["ShiftLeft","LShift"],["ShiftRight","RShift"],["ControlLeft","LCtrl"],["ControlRight","RCtrl"],["AltLeft","LAlt"],["AltRight","RAlt"],["MetaLeft","LWin"],["MetaRight","RWin"],["Escape","Esc"],["F1","F1"],["F2","F2"],["F3","F3"],["F4","F4"],["F5","F5"],["F6","F6"],["F7","F7"],["F8","F8"],["F9","F9"],["F10","F10"],["F11","F11"],["F12","F12"],["Digit0","0"],["Digit1","1"],["Digit2","2"],["Digit3","3"],["Digit4","4"],["Digit5","5"],["Digit6","6"],["Digit7","7"],["Digit8","8"],["Digit9","9"],["KeyA","A"],["KeyB","B"],["KeyC","C"],["KeyD","D"],["KeyE","E"],["KeyF","F"],["KeyG","G"],["KeyH","H"],["KeyI","I"],["KeyJ","J"],["KeyK","K"],["KeyL","L"],["KeyM","M"],["KeyN","N"],["KeyO","O"],["KeyP","P"],["KeyQ","Q"],["KeyR","R"],["KeyS","S"],["KeyT","T"],["KeyU","U"],["KeyV","V"],["KeyW","W"],["KeyX","X"],["KeyY","Y"],["KeyZ","Z"],["ArrowUp","Up"],["ArrowDown","Down"],["ArrowLeft","Left"],["ArrowRight","Right"],["Home","Home"],["End","End"],["PageUp","Page Up"],["PageDown","Page Down"],["Enter","Enter"],["Space","Space"],["Backspace","Backspace"],["Tab","Tab"],["Delete","Delete"],["Insert","Insert"],["CapsLock","Caps Lock"],["NumLock","Num Lock"],["ScrollLock","Scroll Lock"],["Pause","Pause"],["PrintScreen","Print Screen"],["Numpad0","NUMPAD0"],["Numpad1","NUMPAD1"],["Numpad2","NUMPAD2"],["Numpad3","NUMPAD3"],["Numpad4","NUMPAD4"],["Numpad5","NUMPAD5"],["Numpad6","NUMPAD6"],["Numpad7","NUMPAD7"],["Numpad8","NUMPAD8"],["Numpad9","NUMPAD9"],["NumpadMultiply","Mul"],["NumpadAdd","Add"],["NumpadSubtract","Sub"],["NumpadDecimal","Dec"],["NumpadDivide","Div"],["ContextMenu","Apps"],["Help","Help"]]);constructor(){if(k.instance)return k.instance;k.instance=this,this.status=new Map,this.KEYMAP.forEach((t,i)=>{this.status.set(t,!1)}),document.addEventListener("keydown",t=>{const i=this.KEYMAP.get(t.code);this.status.has(i)&&this.status.set(i,!0)}),document.addEventListener("keyup",t=>{const i=this.KEYMAP.get(t.code);this.status.has(i)&&this.status.set(i,!1)}),addEventListener("keydown",t=>{t.preventDefault()})}isKeyDown(t){return this.status.get(t)||!1}isKeysDown(t){let i=!1;return t.forEach(e=>{i=i||this.isKeyDown(e)}),i}}class O{constructor(){this.keyboard=new k,this.mouse=new w,this.keyPrevState=new Map,this.keyCurrState=new Map}update(){[...this.keyboard.KEYMAP.values(),"ClickLeft","ClickRight"].forEach(i=>{this.keyPrevState.set(i,this.keyCurrState.get(i)||!1),this.keyCurrState.set(i,this.isKeyDown(i))})}isKeyDown(t){return t==="ClickLeft"?this.mouse.left:t==="ClickRight"?this.mouse.right:this.keyboard.isKeyDown(t)}isKeysDown(t){return t.some(i=>this.isKeyDown(i))}isAllKeysDown(t){return t.every(i=>this.isKeyDown(i))}isFirstDown(t){return this.keyCurrState.get(t)&&!this.keyPrevState.get(t)}isHeld(t){return this.keyCurrState.get(t)}isReleased(t){return!this.keyCurrState.get(t)&&this.keyPrevState.get(t)}}const u=new O;class S{constructor(){if(S.instance)return S.instance;S.instance=this,this.backgroundMusic=null,this.init()}handleClick=()=>{const t=new Audio;t.muted=!0,t.play().catch(()=>{}),document.removeEventListener("click",this.handleClick)};init(){document.addEventListener("click",this.handleClick)}async load(){this.sounds={},this.soundsURL=await L.loadJSON("assets/audios/Sounds.json");for(const t of Object.keys(this.soundsURL)){this.sounds[t]={};for(const i of Object.keys(this.soundsURL[t])){const e=new Audio(this.soundsURL[t][i]);e.loop=!1,this.sounds[t][i]=e}}}async playSound(t,i=0){const e=this.sounds[t]&&this.sounds[t][i];if(e)if(e.paused)e.currentTime=0,e.play().catch(s=>{console.error(`Error playing sound: ${t+i}`,s)});else{if(t==="walk")return;const s=e.cloneNode();s.currentTime=0,s.play().catch(a=>{console.error(`Error playing sound: ${t+i}`,a)})}}}const P=new S;class v{constructor(){if(v.instance)return v.instance;v.instance=this,this.listeners=new Map}on(t,i){return this.listeners.has(t)||this.listeners.set(t,new Set),this.listeners.get(t).add(i),()=>this.off(t,i)}off(t,i){const e=this.listeners.get(t);e&&e.delete(i)}emit(t,i){const e=this.listeners.get(t);if(e)for(const s of[...e])try{s(i)}catch(a){console.error(`[EventBus] ${t} handler error`,a)}}}const g=new v;class l{constructor(t,i){this.position=t,this.size=i}add(t,i=new Vector(0,0)){return new l(t.addVector(this.position),i.addVector(this.size))}getCenter(){return this.position.addVector(this.size.scale(.5))}getTopLeft(){return this.position}getBottomRight(){return this.position.addVector(this.size)}contains(t){const i=this.getTopLeft(),e=this.getBottomRight();return t.x>=i.x&&t.x<=e.x&&t.y>=i.y&&t.y<=e.y}checkHit(t){const i=this.getTopLeft().x,e=this.getBottomRight().x,s=this.getTopLeft().y,a=this.getBottomRight().y,n=t.getTopLeft().x,h=t.getBottomRight().x,o=t.getTopLeft().y,y=t.getBottomRight().y;return!(e<=n||i>=h||s>=y||a<=o)}checkHits(t,i){for(let e of t)if(this.checkHit(e))return i(),e;return null}merge(t){let i=new Vector(Math.min(this.position.x,t.position.x),Math.min(this.position.y,t.position.y)),e=new Vector(Math.max(this.position.x+this.size.x,t.position.x+t.size.x),Math.max(this.position.y+this.size.y,t.position.y+t.size.y));return F(i,e)}clip(t){let i=new Vector(Math.max(this.position.x,t.position.x),Math.max(this.position.y,t.position.y)),e=new Vector(Math.min(this.position.x+this.size.x,t.position.x+t.size.x),Math.min(this.position.y+this.size.y,t.position.y+t.size.y));return F(i,e)}}const F=(c,t)=>c.x>=t.x||c.y>=t.y?null:new l(c,t.subVector(c));let r=class f{constructor(t=0,i=0){this.x=t,this.y=i}copy(){return new f(this.x,this.y)}getAxis(t){return t===0?this.x:this.y}add(t,i){return new f(this.x+t,this.y+i)}addVector(t){return this.add(t.x,t.y)}sub(t,i){return this.add(-t,-i)}subVector(t){return this.sub(t.x,t.y)}addEqual(t){return this.x+=t.x,this.y+=t.y,this}subEqual(t){return this.x-=t.x,this.y-=t.y,this}scale(t){return new f(this.x*t,this.y*t)}magnitude(){return Math.sqrt(this.x**2+this.y**2)}normalize(){const t=this.magnitude();return t===0?new f(0,0):new f(this.x/t,this.y/t)}dot(t){return this.x*t.x+this.y*t.y}rotate(t){const i=Math.cos(t),e=Math.sin(t),s=this.x*i-this.y*e,a=this.x*e+this.y*i;return new f(s,a)}angle(){return Math.atan2(this.y,this.x)}round(){return new f(Math.round(this.x),Math.round(this.y))}};class J extends l{constructor(t,i,e){super(new r(t.x,t.y),new r(i.x,i.y)),this.type=e}}class U extends l{constructor(t,i,e,s,a={}){super(new r(t.x,t.y),new r(i.x,i.y)),this.type=e,this.autoTrigger=!!s,Object.assign(this,a)}}class D{constructor(){if(D.instance)return D.instance;D.instance=this,this.backgrounds=[],this.blocks=[],this.textures=[],this.interactions=[],this.mapHitBox=new l(new r(0,0),new r(1280,720))}async loadRoom(t,i){const e=`assets/stages/layer${t}/room${i}.json`;try{const s=await L.loadJSON(e);this.rawMapData=JSON.parse(JSON.stringify(s)),this.playerSpawn=s.playerSpawn?{...s.playerSpawn}:null,this.enemySpawns=Array.isArray(s.enemySpawns)?s.enemySpawns.map(o=>({...o})):[],this.backgrounds=(s.backgrounds||[]).map(o=>({...o})),this.blocks=(s.blocks||[]).map(o=>new J(o.position,o.size,o.type)),this.textures=(s.textures||[]).map(o=>({...o}));const a=(s.interactions||[]).map(o=>new U(o.position,o.size,o.type,o.autoTrigger,o));this.interactions=[...a.filter(o=>o.autoTrigger),...a.filter(o=>!o.autoTrigger)],this.blockHitboxes=this.blocks.map(o=>new l(new r(o.position.x,o.position.y),new r(o.size.x,o.size.y)));const n=this.interactions.filter(o=>o.autoTrigger),h=this.interactions.filter(o=>!o.autoTrigger);this.interactionHitboxes=[...n.map(o=>new l(new r(o.position.x,o.position.y),new r(o.size.x,o.size.y))),...h.map(o=>new l(new r(o.position.x,o.position.y),new r(o.size.x,o.size.y)))]}catch(s){console.error("MapManager.loadRoom error:",s)}}getPlayerSpawn(){return this.playerSpawn}getEnemySpawns(){return this.enemySpawns||[]}getBlockHitboxes(){return this.blocks||[]}getInteractionHitboxes(){return this.interactions||[]}draw(t){for(const i of this.backgrounds)this.drawItem(t,i,"background");for(const i of this.blocks)this.drawItem(t,i,"block");for(const i of this.textures)this.drawItem(t,i,"texture")}drawItem(t,i,e){t.save();let s=null,a=e+"s";s=E.getTexture(a,i.type),s?t.drawImage(s,i.position.x,i.position.y,i.size.x,i.size.y):(e==="background"?t.fillStyle="#e0e0e0":e==="block"?t.fillStyle="#654321":e==="texture"?t.fillStyle="#8888ff":t.fillStyle="#cccccc",t.fillRect(i.position.x,i.position.y,i.size.x,i.size.y)),t.restore()}}const d=new D;class M{constructor(t=0){this.t=0,this.cd=t}start(){this.t=this.cd}tick(t){this.t=Math.max(0,this.t-t)}ready(){return this.t===0}reset(){this.t=0}set(t=0){this.cd=t}}class I{constructor(t,i,e,s,a){this.baseJump=t,this.maxJump=i,this.gravity=e,this.coyoteTime=s,this.jumpBuffer=new M(a),this.jumpBufferTime=a,this.isJumping=!1,this.isFalling=!1,this.jumpVelocity=0,this.chargeTime=0,this.coyoteTimer=0,this.times=1}startJump(){this.isJumping=!0,this.isFalling=!1,this.chargeTime=0,this.jumpBuffer.reset(),this.coyoteTimer=0,P.playSound(this.type,"jump")}updateJump(t,i,e){this.jumpBuffer.tick(i),e?(this.coyoteTimer=this.coyoteTime,this.isJumping=!1,this.isFalling=!1,!e&2&&(this.jumpVelocity=0),e&2?this.times=1.5:this.times=1,this.jumpBuffer.ready()||this.startJump()):(this.isJumping||(this.isFalling=!0),this.coyoteTimer=Math.max(this.coyoteTimer-i,0),!this.isJumping&&!this.jumpBuffer.ready()&&this.coyoteTimer>0&&this.startJump()),this.isJumping?!this.isFalling&&t&&this.chargeTime<this.maxJump*this.times?(this.chargeTime+=i,this.jumpVelocity=Math.min(this.baseJump+this.chargeTime/this.maxJump*this.times*(this.maxJump*this.times-this.baseJump),this.maxJump*this.times)):(this.isFalling=!0,this.updateFalling(i)):this.isFalling&&this.updateFalling(i)}updateFalling(t){this.jumpVelocity-=this.gravity*t,this.jumpVelocity=Math.max(-6*this.baseJump,this.jumpVelocity)}}class B{constructor(t,i,e=new r){this.type="",this.velocity=e,this.hitbox=new l(t,i),this.jumping=new I(4,9,.5,8,15),this.MaxSpeed=6,this.attackBox=null,this.hurtBox=null}getCenter(){return this.hitbox.getCenter()}isOnGround(){if(this.velocity.y<0)return!1;this.hitbox.position.y+=1;let t=!1;const i=d.getBlockHitboxes();return t=!!this.hitbox.checkHits(i,()=>{}),this.hitbox.position.y-=1,t&&(this.isflying=0),t}rigidMove(t){let i=this.velocity.scale(t).round(),e=0,s=d.getBlockHitboxes();for(let a=0;a<Math.abs(i.x);++a)if(this.hitbox.position.x+=Math.sign(i.x),this.hitbox.checkHits(s,()=>{this.hitbox.position.x-=Math.sign(i.x)})){e|=1;break}for(let a=0;a<Math.abs(i.y);++a)if(this.hitbox.position.y+=Math.sign(i.y),this.hitbox.checkHits(s,()=>{this.hitbox.position.y-=Math.sign(i.y)})){e|=2;break}return e}updateY(t,i){this.jumping.updateJump(i,t,this.isOnGround())}updateX(t,i){const e=this.isOnGround();let s=this.velocity.x;if(e){if(i===0)s*=Math.exp(-.5*t);else{const a=10*t;s=i*Math.min(Math.sqrt(this.velocity.x*this.velocity.x+a),this.MaxSpeed)}i&&P.playSound(this.type,"walk")}else{const a=.3*t;i!==0?(s+=a*(i*this.MaxSpeed-this.velocity.x),Math.abs(s)>this.MaxSpeed&&(s=this.MaxSpeed*Math.sign(s))):s*=Math.exp(-.05*t)}return s}updateXY(t,i,e){this.updateY(t,e()),this.velocity.y=-this.jumping.jumpVelocity,this.velocity.x=this.updateX(t,i());let s=this.rigidMove(t);s&1&&(this.velocity.x=0),s&2&&(this.velocity.y=this.jumping.jumpVelocity=0)}update(t){t=60*t/1e3,this.updateXY(t,()=>0,()=>0)}draw(t){t.fillStyle="rgba(221, 100, 0, 1)",t.fillRect(this.hitbox.position.x,this.hitbox.position.y,this.hitbox.size.x,this.hitbox.size.y)}}class X extends B{constructor(t,i,e,s,a=new r(10,10)){super(t,a,i),this.type="projectile",this.damage=e,this.alive=!0,this.hurtBox=this.hitbox,this.targetSelector=s,j.add(this)}update(t){if(!this.alive)return;const i=60*t/1e3;if(this.rigidMove(i)){this.alive=!1;return}this.targetSelector().forEach(s=>{this.hurtBox.checkHit(s.hurtBox)&&(s.takeDamage(this.damage),this.alive=!1)})}draw(t){this.alive&&(t.fillStyle="yellow",t.fillRect(this.hitbox.position.x,this.hitbox.position.y,this.hitbox.size.x,this.hitbox.size.y))}}class R{constructor(){if(R.instance)return R.instance;R.instance=this,this.projectiles=[]}add(t){this.projectiles.push(t)}update(t){this.projectiles.forEach(i=>i.update(t)),this.projectiles=this.projectiles.filter(i=>i.alive)}draw(t){this.projectiles.forEach(i=>i.draw(t))}clear(){this.projectiles.length=0}}const j=new R;class _{constructor(t=0){this.duration=t,this.remainingTime=0}start(t=null){t!==null&&(this.duration=t),this.remainingTime=this.duration}tick(t){this.remainingTime=Math.max(0,this.remainingTime-t)}expired(){return this.remainingTime<=0}reset(){this.remainingTime=0}remaining(){return this.remainingTime}set(t){this.duration=t}}const z={player:["ATK","HP","SPD","HEAL","DMG","ENEMY_DMG_DEC","HP_CONTINUES_DEC","MeteeStartupTime","MeteeRecoveryTime","RangedStartupTime","RangedRecoveryTime"],enemy:["ENEMY_ATK","ENEMY_HP","ENEMY_DMG","ENEMY_MeteeStartupTime","ENEMY_MeteeRecoveryTime","ENEMY_RangedStartupTime","ENEMY_RangedRecoveryTime"],boss:[]};class T{constructor(){if(T.instance)return T.instance;T.instance=this,this.attributes={player:{},enemy:{},boss:{}}}_checkAttr(t,i){return z[t]?z[t].includes(i)?!0:(console.warn(`[AttributeManager] ${i} is not valid for type ${t}`),!1):(console.warn(`[AttributeManager] Unknown type: ${t}`),!1)}addAttr(t,i,e,s,a=null,n=null){if(!this._checkAttr(t,i))return;this.attributes[t][i]||(this.attributes[t][i]={}),this.attributes[t][i][s]||(this.attributes[t][i][s]=[]);const h=this.attributes[t][i][s];for(;n&&h.length>=n;)h.shift();const o=a!==null?new _(a):null;o&&o.start(a),h.push({value:e,timer:o})}removeAttrBySource(t,i,e){this.attributes[t][i]&&delete this.attributes[t][i][e]}removeAllAttrBySource(t){for(const i of Object.keys(this.attributes))for(const e of Object.keys(this.attributes[i]))delete this.attributes[i][e][t]}refreshAttrDuration(t,i,e,s){if(!(!this.attributes[t][i]||!this.attributes[t][i][e]))for(const a of this.attributes[t][i][e])a.timer&&a.timer.start(s)}getAttrSum(t,i){if(!this._checkAttr(t,i)||!this.attributes[t][i])return 0;let e=0;for(const s of Object.keys(this.attributes[t][i])){const a=this.attributes[t][i][s];e+=a.reduce((n,h)=>n+h.value,0)}return e}getAttrStackCount(t,i,e){return!this._checkAttr(t,i)||!this.attributes[t][i]||!this.attributes[t][i][e]?0:this.attributes[t][i][e].length}getAllAttrByType(t){if(!z[t])return{};const i={};for(const e of z[t])i[e]=this.getAttr(t,e);return i}getAllAttr(){const t={};for(const i of Object.keys(this.attributes))t[i]=this.getAllAttrByType(i);return t}update(t){for(const i of Object.keys(this.attributes))for(const e of Object.keys(this.attributes[i]))for(const s of Object.keys(this.attributes[i][e])){const a=this.attributes[i][e][s];for(const n of a)n.timer&&n.timer.tick(t);this.attributes[i][e][s]=a.filter(n=>!n.timer||!n.timer.expired()),this.attributes[i][e][s].length===0&&delete this.attributes[i][e][s]}}}const W=new T;class N{constructor(t,i){this.owner=t,this.type=i,this.state="idle",this.timer=0}get damage(){return this.owner.state.attack.damage[this.type]}get startupTime(){return this.owner.state.attack.startupTime[this.type]}get recoveryTime(){return this.owner.state.attack.recoveryTime[this.type]}get targetSelector(){return this.owner.attack.targetSelector}trigger(){return this.state==="idle"?(this.state="startup",this.timer=this.startupTime,!0):!1}update(t){if(this.state!=="idle"&&(this.timer-=t,!(this.timer>0)))switch(this.state){case"startup":this.enterActive();break;case"active":this.enterRecovery();break;case"recovery":this.state="idle";break}}enterActive(){this.state="active",P.playSound(this.owner.type,this.type+"Attack"),this.onHit(this.owner,this.damage)}enterRecovery(){this.state="recovery",this.timer=this.recoveryTime}onHit(t,i){}}class V extends N{constructor(t){super(t,"melee")}onHit(t,i){const s=t.facing>0?t.hitbox.size.x/2:-t.hitbox.size.x/2,a=t.hitbox.position.addVector(new r(s,t.hitbox.size.y*.25)),n=new r(t.hitbox.size.x*.8,t.hitbox.size.y*.5),h=new l(a,n);this.targetSelector().forEach(o=>{h.checkHit(o.hurtBox)&&o.takeDamage(i)})}}class $ extends N{constructor(t){super(t,"ranged")}onHit(t,i){const s=t.facing,a=t.hitbox.getCenter();new X(a,new r(12*s,0),i,this.targetSelector)}}class G{static Framerate={run:6,jump:30,fall:30,stand:8};static Frames={run:6,jump:4,fall:2,stand:7};constructor(){this.status="run",this.facing=1,this.frame=1,this.frameRun=0}setStatus(t,i){(t!=this.status||i!=this.facing)&&(this.frame=1,this.frameRun=0,this.status=t,this.facing=i)}update(t){}getFrame(){return E.getTexture("player",0)}}class C extends B{constructor(t=new r(50,50)){if(C.instance)return C.instance;super(new r,t,new r),C.instance=this,this.size=t,this.type="player",this.jumping.type="player",this.baseState={hp_max:100,attack_baseDamage:10,attack_baseMeleeStartupTime:50,attack_baseMeleeRecoveryTime:900,attack_baseRangedStartupTime:150,attack_baseRangedRecoveryTime:700,dash_cooldownTime:600,dash_maxCount:1,items:[]},this.state={hp:this.baseState.hp_max,hp_max:this.baseState.hp_max,attack:{damage:{melee:this.baseState.attack_baseDamage,ranged:this.baseState.attack_baseDamage},startupTime:{melee:this.baseState.attack_baseMeleeStartupTime,ranged:this.baseState.attack_baseRangedStartupTime},recoveryTime:{melee:this.baseState.attack_baseMeleeRecoveryTime,ranged:this.baseState.attack_baseRangedStartupTime}}},this.attack={targetSelector:()=>m.enemies,melee:new V(this),ranged:new $(this)},this.facing=1,this.animation=new G,this.initDash(),this.hurtBox=this.hitbox,this.invulnerableCooldown=new M(100),this.controllerX=()=>{if(this.blockMove)return 0;let i=u.isKeysDown(["A","Left"]),e=u.isKeysDown(["D","Right"]),s=0;return i&&e?s=0:i?this.facing=s=-1:e&&(this.facing=s=1),s},this.controllerY=()=>this.blockMove?0:(u.isFirstDown("Space")&&this.jumping.jumpBuffer.start(),u.isHeld("Space"))}async update(t){this.invulnerableCooldown.tick(t),u.isKeyDown("J")&&this.attack.melee.trigger(),u.isKeyDown("L")&&this.attack.ranged.trigger(),this.attack.melee.update(t),this.attack.ranged.update(t),this.dash.update(t);const i=60*t/1e3;this.updateXY(i,this.controllerX(),this.controllerY()),this.jumping.jumpVelocity>0?this.animation.setStatus("jump",this.facing):this.isOnGround()?this.animation.setStatus("stand",this.facing):this.jumping.jumpVelocity<0&&this.animation.setStatus("fall",this.facing),this.animation.update(i)}updateXY(t,i,e){this.dash.isDashing||(this.updateY(t,e),this.velocity.y=-this.jumping.jumpVelocity,this.velocity.x=this.updateX(t,i));let s=this.rigidMove(t);s&1&&(this.velocity.x=0,this.dash.isDashing=0),s&2&&(this.velocity.y=this.jumping.jumpVelocity=0)}initDash(){this.dash={isDashing:!1,dashDuration:200,dashCooldownTime:this.baseState.dash_cooldownTime,dashSpeed:15,dashDir:{x:1,y:0},dashDurationCooldown:null,dashCooldown:null,dashMaxCount:this.baseState.dash_maxCount,dashCount:0,update:null},this.dash.dashDurationCooldown=new M(this.dash.dashDuration),this.dash.dashCooldown=new M(this.dash.dashCooldownTime),this.dash.update=t=>{this.isOnGround()&&(this.dash.dashCooldown.tick(t),this.dash.dashCooldown.ready()&&this.dash.dashCount<this.dash.dashMaxCount&&(this.dash.dashCount++,this.dash.dashCooldown.start()));let i=0,e=0;if(u.isKeysDown(["A","Left"])&&(i-=1),u.isKeysDown(["D","Right"])&&(i+=1),u.isKeysDown(["W","Up"])&&(e-=1),u.isKeysDown(["S","Down"])&&(e+=1),!this.dash.isDashing&&this.dash.dashCount>0&&u.isKeyDown("K")){i===0&&e===0&&(i=this.facing);let s=Math.sqrt(i*i+e*e);s===0&&(s=1),this.dash.dashDir={x:i/s,y:e/s},this.dash.isDashing=!0,this.dash.dashDurationCooldown.start(),this.dash.dashCount--,P.playSound("player","dash")}this.dash.isDashing&&(this.dash.dashDurationCooldown.tick(t),this.velocity.x=this.dash.dashSpeed*this.dash.dashDir.x,this.velocity.y=this.dash.dashSpeed*this.dash.dashDir.y,this.dash.dashDurationCooldown.ready()&&(this.dash.isDashing=!1,this.jumping.jumpVelocity=-this.velocity.y))}}takeDamage(t){this.invulnerableCooldown.ready()&&(this.state.hp-=t,this.invulnerableCooldown.start(),console.log(this.state.hp),this.state.hp<=0&&(g.emit("player.die"),alert("你死了")))}setPosition(t){this.hitbox.position=t}draw(t){t.drawImage(this.animation.getFrame(),this.hitbox.position.x,this.hitbox.position.y,this.size.x,this.size.y);const i=this.size.x,e=6,s=this.hitbox.position.x,a=this.hitbox.position.y-12;t.save(),t.fillStyle="red",t.fillRect(s,a,i,e),t.fillStyle="green";const n=Math.max(this.state.hp,0)/this.state.hp_max,h=i*n;t.fillRect(s,a,h,e),t.strokeStyle="black",t.strokeRect(s,a,i,e),t.restore(),this.drawDashUI(t)}drawBoxs(t){t.strokeStyle=this.isInvulnerable?"#cccccc":"#00aaff",t.strokeRect(this.hitbox.position.x,this.hitbox.position.y,this.hitbox.size.x,this.hitbox.size.y),t.strokeStyle="#ff0000";const i=.5*(this.facing>=0?this.hitbox.size.x:-this.hitbox.size.x),e=this.hitbox.position.addVector(new r(i,this.hitbox.size.y*.2)),s=new r(this.hitbox.size.x*.8,this.hitbox.size.y*.5);t.strokeRect(e.x,e.y,s.x,s.y),t.restore()}drawDashUI(t){const i=this.dash.dashMaxCount,e=this.dash.dashCount,s=8,a=4,n=this.hitbox.position.x+this.size.x/2-(i*(s+a)-a)/2,h=this.hitbox.position.y-24;for(let o=0;o<i;o++)t.fillStyle=o<e?"cyan":"gray",t.fillRect(n+o*(s+a),h,s,s),t.strokeStyle="black",t.strokeRect(n+o*(s+a),h,s,s)}}const p=new C;class q{static Framerate={run:6,jump:30,fall:30,stand:8};static Frames={run:6,jump:4,fall:2,stand:7};constructor(){this.status="run",this.facing=1,this.frame=1,this.frameRun=0}setStatus(t,i){(t!=this.status||i!=this.facing)&&(this.frame=1,this.frameRun=0,this.status=t,this.facing=i)}update(t){}getFrame(){return E.getTexture("enemy",0)}}class Q extends B{constructor(t,i,e=new r(50,50),s=new r){super(i,e,s),this.Size=e,this.type="enemy"+t,this.baseState={hp_max:100,attack_baseDamage:10,attack_baseMeleeStartupTime:50,attack_baseMeleeRecoveryTime:900,attack_baseRangedStartupTime:150,attack_baseRangedRecoveryTime:700,items:[]},this.state={hp:this.baseState.hp_max,hp_max:this.baseState.hp_max,attack:{damage:{melee:this.baseState.attack_baseDamage,ranged:this.baseState.attack_baseDamage},startupTime:{melee:this.baseState.attack_baseMeleeStartupTime,ranged:this.baseState.attack_baseRangedStartupTime},recoveryTime:{melee:this.baseState.attack_baseMeleeRecoveryTime,ranged:this.baseState.attack_baseRangedStartupTime}}},this.facing=1,this.animation=new q,this.attack={melee:new V(this),targetSelector:()=>[p]},this.hurtBox=this.hitbox,this.invulnerableCooldown=new M(100),this._unbind_list=[]}async update(t){this.invulnerableCooldown.tick(t);const i=Math.abs(this.hitbox.getCenter().x-p.hitbox.getCenter().x),e=this.hitbox.getCenter().y-p.hitbox.getCenter().y;let s=!1,a="patrol";e>50?i<400&&Math.abs(e)<100&&(a="seek_path",this.hasDirectPathToPlayer()&&(s=Math.random()<.2)):e<-50?i<300&&Math.abs(e)<80&&(a="wait",this.hasSafeDropPath()&&(s=Math.random()<.3)):i<400&&Math.abs(e)<60&&(a="attack",s=Math.random()<.4),s&&this.attack.melee.trigger(),this.attack.melee.update(t),this.updateMovementByMode(a,i,e);const n=60*t/1e3;let h=0;this.updateXY(n,()=>{if(this.blockMove)return 0;if(h=0,a==="attack"||a==="seek_path")this.hitbox.position.x<p.hitbox.position.x?this.facing=h=1:this.facing=h=-1,h*=.3;else if(a==="wait")h=0;else{Math.random()<.002&&(this.facing=Math.random()<.5?1:-1);const o=this.hitbox.position.x+this.facing*2,y=new l(new r(o,this.hitbox.position.y),this.hitbox.size),K=d.getBlockHitboxes();let H=!1;for(const Y of K)if(y.checkHit(Y)){H=!0;break}(H||o<0||o>1280)&&(this.facing=-this.facing),h=this.facing*.2}return h},()=>{if(this.blockMove||!(a==="attack"||a==="seek_path"))return 0},!0),this.jumping.jumpVelocity>0?this.animation.setStatus("jump",this.facing):this.isOnGround()?h?this.animation.setStatus("run",this.facing):this.animation.setStatus("stand",this.facing):this.jumping.jumpVelocity<0&&this.animation.setStatus("fall",this.facing),this.animation.update(n)}hasDirectPathToPlayer(){const t=p.hitbox.position,i=this.hitbox.position,e=d.getBlockHitboxes(),s=new l(new r(Math.min(i.x,t.x),Math.min(i.y,t.y)),new r(Math.abs(t.x-i.x),Math.abs(t.y-i.y)));for(const a of e)if(s.checkHit(a))return!1;return!0}hasSafeDropPath(){p.hitbox.position;const t=this.hitbox.position,i=d.getBlockHitboxes(),e=t.y+100,s=new l(new r(t.x,t.y),new r(this.hitbox.size.x,e-t.y));for(const a of i)if(s.checkHit(a))return!0;return!1}updateMovementByMode(t,i,e){switch(t){case"seek_path":this.seekVerticalPath();break;case"wait":this.waitForPlayer();break;case"attack":this.normalMovement();break;case"patrol":default:this.patrolMovement();break}}seekVerticalPath(){const t=p.hitbox.position,i=this.hitbox.position,e=d.getBlockHitboxes();let s=null,a=1/0;for(const n of e)if(n.position.y<i.y&&n.position.y>t.y-50){const h=Math.abs(n.position.x-i.x);h<a&&(a=h,s=n)}s?this.moveToTarget(s):this.wait()}waitForPlayer(){this.hasSafeDropPath()?this.seekDropPoint():this.patrolMovement()}normalMovement(){}patrolMovement(){Math.random()<.02&&(this.facing=Math.random()<.5?1:-1);const t=this.hitbox.position.x+this.facing*2,i=new l(new r(t,this.hitbox.position.y),this.hitbox.size),e=d.getBlockHitboxes();let s=!1;for(const a of e)if(i.checkHit(a)){s=!0;break}(s||t<0||t>1280)&&(this.facing=-this.facing)}moveToTarget(t){const i=t.position,e=this.hitbox.position;i.x>e.x?this.facing=1:i.x<e.x&&(this.facing=-1),i.y<e.y&&this.isOnGround()&&this.jumping.jumpBuffer.start()}seekDropPoint(){const t=p.hitbox.position,i=this.hitbox.position,e=d.getBlockHitboxes();let s=null,a=1/0;for(const n of e)if(n.position.y>i.y&&n.position.y<t.y+50){const h=Math.abs(n.position.x-i.x);h<a&&(a=h,s=n)}s&&this.moveToTarget(s)}wait(){}takeDamage(t){if(this.invulnerableCooldown.ready()&&(this.state.hp-=t,this.invulnerableCooldown.start(),this.state.hp<=0)){this._unbind_list.forEach(e=>e()),this._unbind_list=[];const i=m.enemies.indexOf(this);i!==-1&&m.enemies.splice(i,1)}}draw(t){t.drawImage(this.animation.getFrame(),this.hitbox.position.x,this.hitbox.position.y,this.Size.x,this.Size.y);const i=this.Size.x,e=6,s=this.hitbox.position.x,a=this.hitbox.position.y-12;t.save(),t.fillStyle="red",t.fillRect(s,a,i,e),t.fillStyle="green";const n=Math.max(this.state.hp,0)/this.state.hp_max,h=i*n;t.fillRect(s,a,h,e),t.strokeStyle="black",t.strokeRect(s,a,i,e),t.restore()}drawBoxs(t){t.strokeStyle=this.isInvulnerable?"#cccccc":"#00aaff",t.strokeRect(this.hitbox.position.x,this.hitbox.position.y,this.hitbox.size.x,this.hitbox.size.y),t.strokeStyle="#ff0000";const i=.5*(this.facing>=0?this.hitbox.size.x:-this.hitbox.size.x),e=this.hitbox.position.addVector(new r(i,this.hitbox.size.y*.25)),s=new r(this.hitbox.size.x*.8,this.hitbox.size.y*.5);t.strokeRect(e.x,e.y,s.x,s.y),t.restore()}}class A{constructor(){if(A.instance)return A.instance;A.instance=this,this.canvas=document.getElementById("canvas"),this.ctx=this.canvas.getContext("2d"),this.isStop=!1,this.isPaused=!1,this.lastTime=0;const t=60;this.targetFrameTime=1e3/t,this.loop=this.loop.bind(this),this.statistics={portal:0,bullet:0,restart:0,jump:0,jumpTime:0}}async init(){await E.load(),await P.load(),await d.loadRoom(1,1);const t=d.getPlayerSpawn();p.setPosition(new r(t.x,t.y)),g.on("tick",({deltaTime:e})=>{u.update(),W.update(e),p.update(e),this.enemies.forEach(s=>s.update(e)),j.update(e)}),g.on("tick_draw",()=>{const e=this.ctx;e.clearRect(0,0,this.canvas.width,this.canvas.height),d.draw(e),p.draw(e),this.enemies.forEach(s=>s.draw(e)),j.draw(e)}),g.on("player.die",()=>this.stop());const i=d.getEnemySpawns();if(this.enemies=[],Array.isArray(i))for(const e of i)this.enemies.push(new Q(e.type,new r(e.x,e.y)))}start(t=0){this.loop(0)}loop(t){const i=t-this.lastTime;!this.isPaused&&!this.isStop&&i>=this.targetFrameTime&&(g.emit("tick",{deltaTime:i}),g.emit("tick_draw")),this.lastTime=t-i%this.targetFrameTime,requestAnimationFrame(this.loop)}pause(){this.isPaused=!0}continue(){this.isPaused=!1}stop(){this.isStop=!0}}const m=new A;window.onload=()=>{m.init().then(()=>{m.start()})};
